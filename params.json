{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"\r\n# Functional Programming\r\n\r\nIts a paradigm of programming, a paradigm according to a dictionary is 'distinct concepts or thought patterns in some scientific discipline'. The main programming paradigms existing are:\r\n\r\n* Imperative Programming\r\n* Functional Programming\r\n* Logic Programming\r\n\r\nOrthogonal to it is:\r\n\r\n* Object-Oriented Programming\r\n\r\nImperative programming is about modifying mutable variables, using assignments and control structure such as if-then-else, loops, break, continue, return. Its like a Von Neumann Computer instruction sequences.\r\n\r\nReference: on scale of imperative programming\r\n```\r\nhttp://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf\r\n```\r\n\r\nA theory is a set of one or more data type, operation on them and laws governing their values and relations. As theory of polynomials there could be theory for all different concepts as String, collections, etc.. however by defining the theories mutation here can destroy key concepts and also few key concepts regarding those.\r\n\r\nFunctional Programming means programming without mutable variables, assignments, loops and other imperative control structures. In a general sense funtional programming\r\n\r\n\r\n## Scala\r\nThese notes assume that the basic of programming are known are hence fast paced, it has the code linked to the same repository all the codes from basics are written in full.\r\n\r\n\r\n### What/Why  Scala?\r\n\r\n    * Expressive\r\n        First-class functions\r\n        Closures\r\n    * Concise\r\n        Type inference\r\n        Literal syntax for function creation\r\n    * Java interopability\r\n        Can reuse java libraries\r\n        Can reuse java tools\r\n        No performance penalty\r\n\r\n### Getting started with scala \r\n\r\n```\r\n\r\n$ sbt console\r\n\r\n[...]\r\n\r\nWelcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).\r\nType in expressions to have them evaluated.\r\nType :help for more information.\r\n\r\nscala>\r\n\r\n```\r\n\r\n### Expressions\r\n\r\n```\r\nscala> 1 + 1\r\nres0: Int = 2\r\n\r\n```\r\n\r\nres0 is an automated value created by interpreter and its Int, could be used further having value 2\r\n\r\n### Values\r\n\r\n```\r\nscala> val two = 1 + 1\r\ntwo: Int = 2\r\n\r\n```\r\n\r\nwe can give the expression a name as we gave two here\r\n\r\n### Variables\r\n\r\n```\r\nscala> var name = \"steve\"\r\nname: java.lang.String = steve\r\n\r\nscala> name = \"marius\"\r\nname: java.lang.String = marius\r\n\r\n```\r\n\r\nwe provide var to define a variable and we wish so that the binding may be changed when ever required.\r\n\r\n\r\n### Funtions\r\n\r\nwe create functions by using def keyword\r\n```\r\nscala> def addOne(m: Int): Int = m + 1\r\naddOne: (m: Int)Int\r\n```\r\n\r\nwe can use the same functions as per the signature as\r\n```\r\nscala> val three = addOne(2)\r\nthree: Int = 3\r\n```\r\n\r\nA function can be also be made by using few lines \r\n```\r\ndef timesTwo(i: Int): Int = {\r\n  println(\"hello world\")\r\n  i * 2\r\n}\r\n```\r\n\r\nFunctions can be created with many inputs as \r\n```\r\nscala> def adder(m: Int, n: Int) = m + n\r\nadder: (m: Int,n: Int)Int\r\n```\r\n\r\nThe same function may be partially used by another function by giving an underscore on one of the arguments as \r\n\r\n```\r\nscala> val add2 = adder(2, _:Int)\r\nadd2: (Int) => Int = <function1>\r\n\r\nscala> add2(3)\r\nres50: Int = 5\r\n```\r\n\r\nEven functions may be defined by using multiple arguments and one being given in a specific funtion\r\n\r\n```\r\nscala> def multiply(m: Int)(n: Int): Int = m * n\r\nmultiply: (m: Int)(n: Int)Int\r\n\r\nscala> multiply(2)(3)\r\nres0: Int = 6\r\n\r\n```\r\n\r\n```\r\nscala> val timesTwo = multiply(2) _\r\ntimesTwo: (Int) => Int = <function1>\r\n\r\nscala> timesTwo(3)\r\nres1: Int = 6\r\n```\r\n\r\nWe can also take any function with multiple arguments and curry it\r\n\r\n```\r\nscala> (adder _).curried\r\nres1: (Int) => (Int) => Int = <function1>\r\n\r\n```\r\n\r\n\r\nif a function can take multiple parameters of repeated type them it can be generalised as\r\n\r\n```\r\ndef capitalizeAll(args: String*) = {\r\n  args.map { arg =>\r\n    arg.capitalize\r\n  }\r\n}\r\n```\r\n\r\n### Classes\r\n\r\nClasses are objects with various methods and variables may be defined as:\r\n\r\n```\r\nscala> class Calculator {\r\n     |   val brand: String = \"HP\"\r\n     |   def add(m: Int, n: Int): Int = m + n\r\n     | }\r\ndefined class Calculator\r\n\r\nscala> val calc = new Calculator\r\ncalc: Calculator = Calculator@e75a11\r\n\r\nscala> calc.add(1, 2)\r\nres1: Int = 3\r\n\r\nscala> calc.brand\r\nres2: String = \"HP\"\r\n\r\n```\r\n\r\n### Constructor\r\n\r\n```\r\nclass Calculator(brand: String) {\r\n  /**\r\n   * A constructor.\r\n   */\r\n  val color: String = if (brand == \"TI\") {\r\n    \"blue\"\r\n  } else if (brand == \"HP\") {\r\n    \"black\"\r\n  } else {\r\n    \"white\"\r\n  }\r\n\r\n  // An instance method.\r\n  def add(m: Int, n: Int): Int = m + n\r\n}\r\n```\r\n\r\nAs we could see a constructor is defined foe the state of the variables. Also we could see we have discussed two different ways we can comment in Scala.\r\n\r\nAlso we could see that Scala is more expression based rather than statement oriented.\r\n\r\n### Inheritance\r\n\r\nneed to include this http://www.scala-lang.org/node/125\r\n\r\na general example of Inheritance is \r\n\r\n\r\n```\r\nclass ScientificCalculator(brand: String) extends Calculator(brand) {\r\n  def log(m: Double, base: Double) = math.log(m) / math.log(base)\r\n}\r\n```\r\n\r\n### Abstract Classes\r\n\r\nWe can define abstract classes too having just the method definitions but they cannot be called while defining a variable.\r\n\r\n```\r\n\r\nscala> abstract class Shape {\r\n     |   def getArea():Int    // subclass should define this\r\n     | }\r\ndefined class Shape\r\n\r\nscala> class Circle(r: Int) extends Shape {\r\n     |   def getArea():Int = { r * r * 3 }\r\n     | }\r\ndefined class Circle\r\n\r\nscala> val s = new Shape\r\n<console>:8: error: class Shape is abstract; cannot be instantiated\r\n       val s = new Shape\r\n               ^\r\n\r\nscala> val c = new Circle(2)\r\nc: Circle = Circle@65c0035b\r\n\r\n```\r\n\r\n### Traits\r\n\r\ntraits are collections of fields and behaviors that you can extend or mixin to your classes.\r\n\r\n```\r\n\r\ntrait Car {\r\n  val brand: String\r\n}\r\n\r\nclass BMW extends Car {\r\n  val brand = \"BMW\"\r\n}\r\n\r\nclass BMW extends Car with Shiny {\r\n  val brand = \"BMW\"\r\n  val shineRefraction = 12\r\n}\r\n\r\n```\r\n\r\n\r\n### References / QA\r\n\r\n```\r\nhttp://stackoverflow.com/questions/1991042/scala-traits-vs-abstract-classes\r\nhttp://stackoverflow.com/questions/2005681/difference-between-abstract-class-and-trait\r\nhttp://www.artima.com/pins1ed/traits.html#12.7\r\n```\r\n\r\n\r\n## sbt - simple build tool\r\n\r\nIts a build written in scala provides major conveniences of Scala. It provides a full language support for creating tasks. Launches REPL in project context and had a continuous command execution. Other advantages are\r\n* Generated docs by scaladoc\r\n* Supports mixed Scala/Java projects\r\n* Supports Testing with ScalaCheck, specs, and ScalaTest (JUnit is supported by a plugin)\r\n* Sub-project support (put multiple packages in one project)\r\n* External project support (list a git repository as a dependency!)\r\n* Parallel task execution, including parallel test execution\r\n\r\n\r\n### Getting Started\r\n\r\nIt is now bundled with a lot of operating systems some of their commands are\r\n```\r\nyum install sbt\r\n\r\napt-get install sbt\r\n* in few cases this might be needed to be added http://apt.typesafe.com/repo-deb-build-0002.deb\r\n\r\nsudo port install sbt\r\n\r\nbrew install sbt\r\n```\r\nFor windows the MSI is given at \r\n```\r\nhttp://scalasbt.artifactoryonline.com/scalasbt/sbt-native-packages/org/scala-sbt/sbt/0.12.0/sbt.msi\r\n```\r\nOR Manually:\r\nDownload the sbt jar from \r\n```\r\nhttp://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.12.0/sbt-launch.jar\r\n```\r\nand put it in the ~/bin directory of the project, write a script to run the jar \r\n```\r\njava -Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=384M -jar `dirname $0`/sbt-launch.jar \"$@\"\r\n```\r\nMake the script Executable\r\n```\r\nchmod u+x ~/bin/sbt\r\n```\r\n\r\n### Creating a Sample Project\r\n\r\nLets create a Simple hello world scala code as\r\n```\r\nobject Hi {\r\n  def main(args: Array[String]) = println(\"Hi!\")\r\n}\r\n```\r\n\r\nand a build.sbt file as\r\n\r\n```\r\n\r\nname := \"hello\"\r\n\r\nversion := \"1.0\"\r\n\r\nscalaVersion := \"2.9.1\"\r\n\r\n```\r\nand running as would run the code \r\n\r\n```\r\nsbt run\r\n\r\n```\r\nSome commands with sbt are:\r\n\r\n\r\n* clean Deletes all generated files (in the target directory).\r\n* compile Compiles the main sources (in src/main/scala and src/main/java directories).\r\n* test Compiles and runs all tests.\r\n* console Starts the Scala interpreter with a classpath including the compiled sources and all dependencies. To return to sbt, type :quit, Ctrl+D (Unix), or Ctrl+Z (Windows).\r\n* run <argument>* Runs the main class for the project in the same virtual machine as sbt.\r\n* package Creates a jar file containing the files in src/main/resources and the classes compiled from src/main/scala and src/main/java.\r\n* help <command> Displays detailed help for the specified command. If no command is provided, displays brief descriptions of all commands.\r\n* reload Reloads the build definition (build.sbt, project/*.scala, project/*.sbt files). Needed if you change the build definition.\r\n\r\n\r\n### Understanding sbt\r\n\r\n\r\n### Authors and Contributors\r\nIn 2012, Vidyasagar N (@vidyasagar1729)\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? contact me at vidyasagar1729@gmail.com and I'll get back to you as soon as possible.","tagline":"Some Scala Learning","name":"Scala-skunkworks","google":""}